<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
<script>
/*
    假设这是一个汽车店，多种型号的汽车出售
 */
/* $A型号的汽车的服务类型 */
function $A(){};
$A.prototype = {
    //组装
    assemble:function(){console.log(111)},
    //清洗
    wash:function(){},
    //维修
    repair:function(){}
}
//自己的汽车店
var CarShop = function(){}
CarShop.prototype = {
    carssell:function(model){
        var cars = this.createCar(model);
        cars.assemble();
        cars.wash();
        return cars;
    },
    createCar:function(){
        throw new Error('NO')
    }
}

//两个子类，分别从zh,gy公司进货
function  extend(subClass,superClass){
  function F(){}

  F.prototype = superClass.prototype;
  subClass.prototype = new F();
  subClass.prototype.constructor = subClass;

  if (superClass.prototype.constructor === Object.prototype.constructor) {
      superClass.prototype.constructor = superClass;
  }
}

//hz class
var hzCarShop = function(){}
extend(hzCarShop,CarShop);
hzCarShop.prototype.createCar = function(model){
    var car;
    switch (model) {
        case 'The A':
            cars = new $A();
            break;
        case 'The B':
            cars = new $B();
            break;
        // 新增加的类型
        case 'The D':
            cars = new $D();
            break;
        case 'The C':
        default:
            cars = new $C()
    }
    return cars;
}
//gy class
var gyCarShop = function(){};
extend(gyCarShop,CarShop);
gyCarShop.prototype.createCar = function(model){
    var cars ;
    switch (model) {
        case 'The A':
            cars = new $A();
            break;
        case 'The B':
            cars = new $B();
            break;
        // 新增加的类型
        case 'The D':
            cars = new $D();
            break;
        case 'The C':
        default:
            cars = new $C()
    }
    return cars;
};

var californiaCruisers = new hzCarShop();
var yourNewBike = californiaCruisers.carssell('The A');


//XHR
/*根据浏览器的不同来生成一个XMLhttpRequest或者ActiveXObject实例*/

var AjaxHandler = new Interface('AjaxHandler',['request','createXhrObject']);

var $handler = function(){};

$handler.prototype = {
    request:function(method,url,callback,postVar){
        var xhr = this.createXhrObject();
        xhr.onreadystatechange = function(){
            if (xhr.readystate !== 4) {
                return ;
            }
            ((xhr.status>=200 && xhr.status<300) || xhr.status === 304 ?callback.success(xhe.responseText,xhr.responseXML) : callback.failure(xhr.status))
        };
        xhr.open(method,url,true);
        if (method !== "POST") {
            postVar = null;
        }
        xhr.send(postVar)
    },
    createXhrObject:function(){
        var methods = [
            function(){
                return new XMLHttpRequest();
            },
            function(){
                return new ActiveXObject('MSXML2.XMLHTTP.3.0');
            },
            function(){
                return new ActiveXObject('MSXML.XMLHTTP')
            },
            function(){
                return new ActiveXObject('Microsoft.XMLHTTP')
            }
        ];
        for(var i=0,len=methods.length;i<len;i++){
            try {
                methods[i]();
            } catch (e) {
                continue;
            }
            this.createXhrObject = methods[i];
            return methods[i]();
        }

        throw new Error("Handler:Could not create an XHR object.");
    }
}







    /*
    337  createXhrObject这个工厂方法根据当前环境的具体情况返回一个XHR对象。在首次执行时，它会依次尝试三种用于创建XHR对象的不同方法，一旦遇到一种管用的，它就会返回创建的对象并将自身改为用以创建那个对象的函数。这个新函数于是变成了createXhrObject方法，这种技术被称为memoizing，它可以用来创建存储着复杂计算的函数和方法，以免再次进行这种计算。所有那些复杂的设置代码只会在方法首次执行时被调用一次，此后就只有针对当前浏览器的代码会被执行。
    338  */
    339
    340 // 用SimpleHandler类发起一部请求的过程
    341 var myHandler = new SimpleHandler();
    342 var callback = {
        343     success: function(responseText) {
            344         alert('Success:' + responseText);
            345
        },
        346     failure: function(statusCode) {
            347         alert('Failure:' + statusCode);
            348
        }
349 };
    350 myHandler.request('GET', 'script.php', callback);
    351
    352
    353 // 专用型连接对象
    354 /*
355  这个例子可以进一步扩展，把工厂模式用在两个地方，以便根据网络条件创建专门的请求对象。在创建XHR对象时已经用过了简单工厂模式。另一个工厂则用来返回各种处理器类，它们都派生自SimpleHandler。
356  首先要做的是创建两个新的处理器类。QueuedHandler会在发起新的请求之前先确保所有请求都已经成功处理。而OfflineHandler则会在用户处于离线状态时把请求缓存起来。
357  */
    358 /* QueueHandler class */
    359 var QueuedHandler = function () {       // implements AjaxHandler
        360     this.queue = [];        // 保存请求队列
        361     this.requestInProgress = false;     // 请求进程，是否完成
        362     this.retryDelay = 5;        // In seconds   延时（秒）
        363
    };
    364 extend(QueuedHandler, SimpleHandler);
    365 /**
366  *
367  * @param {Boolean} override 是否需要覆盖请求
368  */
    369 QueuedHandler.prototype.request = function (method, url, callback, postVars, override) {
        370     if (this.requestInProgress && !override) {
            371         // 其它请求正在进行中且不覆盖请求
            372         this.queue.push({
                373             method: method,
                374             url: url,
                375             callback: callback,
                376             postVars: postVars
377         });
            378
        } else {
            379         // 当前没有请求进行，立刻执行该请求
            380         // 执行成功后递归
            381         this.requestInProgress = true;
            382         var xhr = this.createXhrObject();
            383         var that = this;
            384         xhr.onreadystatechange = function () {
                385             if (xhr.readyState !== 4) {
                    386                 return;
                    387
                }
                388             if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {
                    389                 // 该请求成功，执行对应队列的成功方法
                    390                 callback.success(xhr.responseText, xhr.responseXML);
                    391                 // 处理位于最前队列的请求
                    392                 that.advanceQueue();
                    393
                } else {
                    394                 callback.failure(xhr.status);
                    395                 setTimeout(function () {
                        396                     that.request(method, url, callback, postVars, true);
                        397
                    }, that.retryDelay * 1000);
                    398
                }
                399
            };
            400         xhr.open(method, url, true);
            401         if (method !== 'POST') {
                402             postVars = null;
                403
            }
            404         xhr.send(postVars);
            405
        }
        406
    };
    407
    408 QueuedHandler.prototype.advanceQueue = function () {
        409     if (this.queue.length === 0) {
            410         this.requestInProgress = false;
            411         return;
            412
        }
        413     var req = this.queue.shift();
        414     this.request(req.method, req.url, req.callback, req.postVars, true);
        415
    };
    416
    417 /*
418  QueueHandler的request方法与SimpleHandler的看上去差不多，但在允许发起新请求之前它会先检查一下，以确保当前没有别的请求正在处理。如果有哪个请求未能成功处理，那么它还会在指定的时间间隔之后再次重复这个请求，直到该请求被成功处理为止。
419  */
    420
    421 /* OfflineHandler class */
    422 var OfflineHandler = function () {      // implements AjaxHandler
        423     this.storedRequests = [];
        424
    };
    425 extend(OfflineHandler, SimpleHandler);
    426 OfflineHandler.prototype.request = function (method, url, callback, postVars) {
        427     if (XhrManager.isOffline()) {
            428         // Store the requests until we are online
            429         this.storedRequests.push({
                430             method: method,
                431             url: url,
                432             callback: callback,
                433             postVars: postVars
434         });
            435
        } else {
            436         // Call SimpleHandler's request method if we are online
            437         this.flushStoredRequests();
            438         OfflineHandler.superclass.request(method, url, callback, postVars);
            439
        }
        440
    };
    441 OfflineHandler.prototype.flushStoredRequests = function () {
        442     for (var i = 0, len = this.storedRequests.length; i < len; i++) {
            443         var req = this.storedRequests[i];
            444         OfflineHandler.superclass.request(req.method, req.url, req.callback, req.postVars);
            445
        }
        446
    };
    447 /*
448  XhrManager.isOffline方法的作用在于判断用户时都处于在线状态。OfflineHandler只有在用户处于在线状态时才会使用SimpleHandler的request方法实际发起请求。而且一旦探测到用户处于在线状态，它还会立即执行所有缓存中的请求。
449  */
    450
    451 /* XhrManager singleton */
    452 var XhrManager = {
        453     createXhrHandler: function() {
            454         var xhr;
            455         if (this.isOffline()) {
                456             xhr = new OfflineHandler();
                457
            } else if (this.isHighLatency()) {
                458             xhr = new QueuedHandler();
                459
            } else {
                460             xhr = new SimpleHandler();
                461
            }
            462
            463         Interface.ensureImplements(xhr, AjaxHandler);
            464         return xhr;
            465
        },
        466     test: function() {
            467         this.timer = {};
            468         this.timeout = 8000;
            469         var that = this;
            470         var myHandler = new SimpleHandler();
            471         var callback = {
                472             success: function(responseText) {
                    473                 window.clearTimeout(that.timer);
                    474                 alert('Success:' + responseText);
                    475
                },
                476             failure: function(statusCode) {
                    477                 alert('Failure:' + statusCode);
                    478
                }
479         };
            480
            481         this.timer = window.setTimeout(that.test, that.timeout);
            482         myHandler.request('GET', 'script.php', callback);
            483
        },
        484     isOffline: function() {
            485         // Do a quick request with SimpleHandler and
            486         // see if it succeeds
            487
            488
            489
        },
        490     isHighLatency: function() {
            491         // Do a series of requests with SimpleHandler and
            492         // time the responses.Best done once, as a
            493         // branching function.
            494
        }
495 };
    496
    497 var myHandler = XhrManager.createXhrHandler();
    498 var callback = {
        499     success: function(responseText) {
            500         alert('Success: ' + responseText);
            501
        },
        502     failure: function(statusCode) {
            503         alert('Failure: ' + statusCode);
            504
        }
505 };
    506 myHandler.request('GET', 'script.php', callback);
    507
    508 /*
509  createXhrHandler方法返回的各种对象都具有我们所需要的一些方法。而且，因为它们都派生自SimpleHandler，所以createXhrObject这个复杂的方法只需要在这个类中实现一次即可，那些子类可以使用这个方法。OfflineHandler中还有多处使用了SimpleHandler的request方法，这进一步实现了代码的重用。
510  */
    511
    512 // 工厂模式之利
    513 /*
514  工厂模式的主要好处在于消除对象间的耦合。通过使用工厂方法而不是new关键字及具体类。你可以把所有实例化代码集中在一个位置。这可以大大简化更换所用的类或在运行期间动态选择所用的类的工作。在派生子类时它也提供了更大的灵活性。使用工厂模式，你可以创建一个抽象的父类，然后在子类中创建工厂方法，从而把成员对象的实例化推迟到更专门化的子类中进行。
515  所有这些好处都与面向对象涉及的这两条原则有关：弱化对象间的耦合;防止代码的重用。这些都有助于创建模块化的代码。
516  */
    517
    518 // 工厂模式之弊
    519 /*
520  如果根本不可能另外换用一个类，或者不需要在运行期间在一系列可互换的类中进行选择，那就不应该使用工厂方法。大多数类最好使用new关键字和构造函数公开地进行实例化。这可以让代码更简单易读。你可以一眼就看到调用的是什么构造函数，而不必去查看某个工厂方法以便知道实例化的是什么类。工厂方法在其使用场合非常有用，但切勿滥用。
521  */
    522
    523 /*
524  相关模式
525 
526  * 简单工厂和抽象工厂模式
527  *
528  简单工厂使用来选择实现的，可以选择任意接口的实现。一个简单工厂可以有多个用于选择并创建对象的方法，多个方法创建的对象可以有关系也可以没有关系。
529  抽象工厂模式使用来选择产品簇的实现的，也就是说一般抽象工厂里面有多个用于选择并创建对象的方法，但是这些方法所创建的对象之间通常是有关系的，这些被创建的对象通常是构成一个产品簇所需要的部件对象。
530  所以从某种意义上来说，简单工厂和抽象工厂是类似的，如果抽象工厂退化成为只有一个实现，不分层次，那么就相当于简单工厂了。
531 
532  * 简单工厂和工厂方法模式
533  *
534  工厂方法的本质也使用来选择实现的，跟简单工厂的区别在于工厂方法是把选择具体实现的功能延迟到子类去实现。
535  如果把工厂方法中选择的是先放到父类直接实现，那就等于简单工厂。
536 
537  *简单工厂和能创建对象实例的模式
538  *
539  简单工厂可以跟其他任何能够具体的创建对象实例的模式配合使用，比如：单例模式，原型模式，生成器模式等。
540 
541  * 工厂方法和模板方法模式
542  *
543  这两个模式外观类似，都有一个抽象类，然后由子类来提供一些实现，但是工厂方法模式的子类专注的是创建产品对象，而模板方法模式的子类专注的是为固定算法骨架提供某些步骤的实现。
544  这两个模式可以组合使用，通常在模板方法模式里面，使用工厂方法来创建末班方法需要的对象。
545  */
    546
    547
    548 /* AjaxHandler interface */
    549 var AjaxHandler = new Interface('AjaxHandler', ['request', 'createXhrObject']);
    550
    551 /* SimpleHandler class */
    552 var SimpleHandler = function () {
        553
    };     // implements AjaxHandler
    554 SimpleHandler.prototype = {
        555     request: function(method, url, callback, postVars) {
            556         var xhr = this.createXhrObject();
            557         xhr.onreadystatechange = function () {
                558             if (xhr.readyState !== 4) {
                    559                 return;
                    560
                }
                561((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) ?
                    562                 callback.success(xhr.responseText, xhr.responseXML) :
                563                 callback.failure(xhr.status);
                564
            };
            565         xhr.open(method, url, true);
            566         if (method !== 'POST') {
                567             postVars = null;
                568
            }
            569         xhr.send(postVars);
            570
        },
        571     createXhrObject: function() {      // Factory method
            572         var methods = [
                573             function () {
                    574                 return new XMLHttpRequest();
                    575
                },
                576             function () {
                    577                 return new ActiveXObject('Msxml2.XMLHTTP');
                    578
                },
                579             function () {
                    580                 return new ActiveXObject('Microsoft.XMLHTTP');
                    581
                }
582];
            583
            584         for (var i = 0, len = methods.length; i < len; i++) {
                585             try {
                    586                 methods[i]();
                    587
                } catch (e) {
                    588                 continue;
                    589
                }
                590             // if we reach this point,method[i] worked
                591             this.createXhrObject = methods[i];    // Memoize the method
                592             return methods[i]();
                593
            }
            594
            595         // if we reach this point,none of the methods worked
            596         throw new Error('SimpleHandler:Could not create an XHR object.');
            597
        }
598 };
    599
    600 function $() {
        601     var elements = [];
        602     for (var i = 0; i < arguments.length; i++) {
            603         var element = arguments[i];
            604         if (typeof element == 'string') {
                605             element = document.getElementById(element);
                606
            }
            607         if (arguments.length === 1) {
                608             return element;
                609
            }
            610         elements.push(element);
            611
        }
        612     return elements;
        613
    }
    614
    615 /*------------------
616  显示类，它把输出内容包装为一个无序列表
617  --------------------*/
    618 /* DisplayModule interface */
    619 var DisplayModule = new Interface('DisplayModule', ['append', 'remove', 'clear']);
    620
    621 /* ListDisplay class. */
    622 var ListDisplay = function (id, parent) {
        623     // implements Display
        624     this.list = document.createElement('ul');
        625     this.list.id = id;
        626     parent.appendChild(this.list);
        627
    };
    628 ListDisplay.prototype = {
        629     append: function(text) {
            630         var newEl = document.createElement('li');
            631         this.list.appendChild(newEl);
            632         newEl.innerHTML = text;
            633         return newEl;
            634
        },
        635     remove: function(el) {
            636         this.list.removeChild(el);
            637
        },
        638     clear: function() {
            639         this.list.innerHTML = '';
            640
        }
641 };
    642
    643 /* 配置对象，它包含着一些供阅读器类及其成员对象使用的设置 */
    644 /* Configuration */
    645 var conf = {
        646     id: 'cnn-top-stories',
        647     feedUrl: 'http://rss.cnn.com/rss/cnn_topstories.rss',
        648     updateInterval: 60, // In seconds
        649     parent: $('feed-readers')
650 };
    651
    652 /* FeedReader类用XHR处理器从RSS源获取XML格式的数据并用一个内部方法对其进行解析，然后用显示模块将解析出来的信息输出到网页上 */
    653 /* FeedReader class. */
    654 var FeedReader = function (display, xhrHandler, conf) {
        655     this.display = display;
        656     this.xhrHandler = xhrHandler;
        657     this.conf = conf;
        658
        659     this.startUpdates();
        660
    };
    661 FeedReader.prototype = {
        662     fetchFeed: function() {
            663         var that = this;
            664         var callback = {
                665             success: function(text, xml) {
                    666                 that.parseFeed(text, xml);
                    667
                },
                668             failure: function(status) {
                    669                 that.showError(status);
                    670
                }
671         };
            672         this.xhrHandler.request('GET', 'feedProxy.php?feed=' + this.conf.feedUrl, callback);
            673
            674
        },
        675     parseFeed: function(responseText, responseXML) {
            676         this.display.clear();
            677         var items = responseXML.getElementsByTagName('item');
            678         for (var i = 0, len = items.length; i < len; i++) {
                679             var title = items[i].getElementsByTagName('title')[0];
                680             var link = items[i].getElementsByTagName('link')[0];
                681             this.display.append('<a href="' + link.firstChild.data + '">' + title.firstChild.data + '"</a>');
                682
            }
            683
        },
        684     showError: function(statusCode) {
            685         this.display.clear();
            686         this.display.append('Error fetching feed.');
            687
        },
        688     stopUpdates: function() {
            689         clearInterval(this.interval);
            690
        },
        691     startUpdates: function() {
            692         this.fetchFeed();
            693         var that = this;
            694         this.interval = setInterval(function () {
                695             that.fetchFeed();
                696
            }, this.conf.updateInterval * 1000);
            697
        }
698 };
    699
    700 /* 把所有类和对象拼装恰来的工厂方法 */
    701 /* FeedManager namespace */
    702 var FeedManager = {
        703     createFeedReader: function(conf) {
            704         var displayModule = new ListDisplay(conf.id + '-display', conf.parent);
            705         var simpleHandler = new SimpleHandler();
            706         var xhrHandler = simpleHandler.createXhrObject();
            707
            708         return new FeedReader(displayModule, xhrHandler, conf);
            709
        }
710 };
    711
    712
    713 /* Title: Factory method
714  Description: creates objects without specifying the exact class to create
715  */
    716 var jsp = {};
    717 jsp.dom = {};
    718 jsp.dom.Text = function () {
        719     this.insert = function (where) {
            720         var txt = document.createTextNode(this.url);
            721         where.appendChild(txt);
            722
        };
        723
    };
    724 jsp.dom.Link = function () {
        725     this.insert = function (where) {
            726         var link = document.createElement('a');
            727         link.href = this.url;
            728         link.appendChild(document.createTextNode(this.url));
            729         where.appendChild(link);
            730
        };
        731
    };
    732 jsp.dom.Image = function () {
        733     this.insert = function (where) {
            734         var im = document.createElement('img');
            735         im.src = this.url;
            736         where.appendChild(im);
            737
        };
        738
    };
    739 jsp.dom.factory = function (type) {
        740     return new jsp.dom[type];
        741
    }
    742
    743 var o = jsp.dom.factory('Link');
    744 o.url = 'http://google.com';
    745 o.insert(document.body);
    746
    747
    748 /*
749  工厂方法模式与IoC与DI
750 
751  Ioc --- Inversion of Control， 控制反转
752  DI  --- Dependency Injection， 依赖注入
753 
754  1）.参与者有谁？
755  一般有三方参与者，一个是某个对象（任意对象）；另一个是Ioc/DI的容器（用来实现IoC/DI功能的一个框架程序）；还有一个是某个对象的外部资源（对象需要的，但是是从对象外部获取的，都统称为资源）。
756  2）.谁依赖于谁？
757  某个对象依赖于IoC/DI的容器
758  3）.为什么需要依赖？
759  对象需要Ioc/DI的容器来提供对象需要的外部资源。
760  4）.谁注入谁？
761  Ioc/DI的容器注入某个对象。
762  5）.到底注入什么？
763  注入的是某个对象所需要的外部资源。
764  6）.谁控制谁？
765  IoC/DI的容器来控制对象。
766  7）.控制什么？
767  主要是控制对象实例的创建。
768  8）.为何叫反转？
769  反转是相对于正向而言的。
770  在A类中主动去获取所需要的外部资源C，这种情况被称为正向的。反向就是A类不再主动去获取C，而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向地注入到A类中。
771  9）.依赖注入和控制反转是同一个概念吗？
772  依赖注入和控制反转是对同一件事情的不同描述。依赖注入是从应用程序的角度去描述。应用程序依赖容器创建并注入它所需要的外部资源。
773  而控制反转是从容器的角度去描述，容器控制应用程序，由容器反向地向应用程序注入其所需要的外部资源。
774 
775  这么一个小小的改变其实是编程思想的一个大进步，有效地分离了对象和它所需要的外部资源，使它们松散耦合，有利于功能服用，更重要的是使得程序的整个体系结构变得非常灵活。
776 
777 
778  */
    779
    780 // 用setter注入，使用Ioc/DI的示例
    781 var A = function () {
        782     this.c = null;
        783
    };
    784 A.prototype = {
        785     setC: function(c) {
            786         // 注入
            787         this.c = c;
            788
        },
        789     t1: function() {
            790         // 等待注入
            791         this.c.tc();
            792
        }
793 };
    794
    795 var C = function () {
        796
    };
    797 C.prototype.tc = function () {
        798     console.log('instance C method');
        799
    };
    800
    801(new A()).setC(new C()).t1();
    802
    803 // 工厂方法实现Ioc/DI
    804 var A = function () {
        805
    };
    806 A.prototype = {
        807     createC1: function() {
            808
        },
        809     t1: function() {
            810         this.createC1().tc();
            811
        }
812 };
    813 // 子类实现注入
    814 var A2 = function () {
        815     this.superclass.constructor.apply(this, arguments);
        816
    };
    817 extend(A, A2);
    818 A2.prototype.createC1 = function () {
        819     return new C();
        820
    };
    821
    822
    823 // http://www.dofactory.com/javascript-factory-method-pattern.aspx
    824
    825(function () {
        826     function Factory() {
            827         this.createEmployee = function (type) {
                828             var employee;
                829
                830             if (type === "fulltime") {
                    831                 employee = new FullTime();
                    832
                } else if (type === "parttime") {
                    833                 employee = new PartTime();
                    834
                } else if (type === "temporary") {
                    835                 employee = new Temporary();
                    836
                } else if (type === "contractor") {
                    837                 employee = new Contractor();
                    838
                }
                839
                840             employee.type = type;
                841             employee.say = function () {
                    842                 log.add(this.type + ": rate " + this.hourly + "/hour");
                    843
                }
                844             return employee;
                845
            }
            846
            847
        }
        848
        849     var FullTime = function () {
            850         this.hourly = "$12";
            851
        };
        852     var PartTime = function () {
            853         this.hourly = "$11";
            854
        };
        855     var Temporary = function () {
            856         this.hourly = "$10";
            857
        };
        858     var Contractor = function () {
            859         this.hourly = "$15";
            860
        };
        861
        862 // log helper
        863     var log = (function () {
            864         var log = "";
            865         return {
                866             add: function(msg) {
                    867                 log += msg + "\n";
                    868
                },
                869             show: function() {
                    870                 alert(log);
                    871                 log = "";
                    872
                }
873         }
            874
        })();
        875
        876
        877     function run() {
            878
            879         var employees = [];
            880
            881         var factory = new Factory();
            882
            883         employees.push(factory.createEmployee("fulltime"));
            884         employees.push(factory.createEmployee("parttime"));
            885         employees.push(factory.createEmployee("temporary"));
            886         employees.push(factory.createEmployee("contractor"));
            887
            888         for (var i = 0, len = employees.length; i < len; i++) {
                889             employees[i].say();
                890
            }
            891
            892         log.show();
            893
        }
        894
    }());
</script>
</body>
</html>